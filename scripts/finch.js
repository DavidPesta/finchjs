/*
	Finch.js - Powerfully simple javascript routing
	by Rick Allen and Greg Smith

	Version 0.2.0
	Full source at https://github.com/stoodder/finchjs
	Copyright (c) 2011 RokkinCat, http://www.rokkincat.com

	MIT License, https://github.com/stoodder/finchjs/blob/master/LICENSE.md
	This file is generated by `cake build`, do not edit it by hand.
*/
(function() {
  var Finch, NodeType, NullPath, RouteNode, RoutePath, RouteSettings, addRoute, arraysEqual, contains, currentParameters, currentPath, currentTargetPath, endsWith, extend, findNearestCommonAncestor, findPath, getChildRouteString, getComponentName, getComponentType, getParentRouteString, isArray, isFunction, isNumber, isObject, isString, objectsEqual, parseQueryString, resetGlobals, rootNode, splitRouteString, startsWith, step, trim, trimSlashes;

  isObject = function(object) {
    return typeof object === typeof {};
  };

  isFunction = function(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
  };

  isArray = function(object) {
    return Object.prototype.toString.call(object) === "[object Array]";
  };

  isString = function(object) {
    return Object.prototype.toString.call(object) === "[object String]";
  };

  isNumber = function(object) {
    return Object.prototype.toString.call(object) === "[object Number]";
  };

  trim = function(str) {
    return str.replace(/^\s+/, '').replace(/\s+$/, '');
  };

  trimSlashes = function(str) {
    return str.replace(/^\/+/, '').replace(/\/+$/, '');
  };

  startsWith = function(haystack, needle) {
    return haystack.indexOf(needle) === 0;
  };

  endsWith = function(haystack, needle) {
    return haystack.indexOf(needle, haystack.length - needle.length) !== -1;
  };

  contains = function(haystack, needle) {
    return haystack.indexOf(needle) !== -1;
  };

  extend = function(obj, extender) {
    var key, value;
    if (!isObject(obj)) obj = {};
    if (!isObject(extender)) extender = {};
    for (key in extender) {
      value = extender[key];
      obj[key] = value;
    }
    return obj;
  };

  objectsEqual = function(obj1, obj2) {
    var key, value;
    for (key in obj1) {
      value = obj1[key];
      if (obj2[key] !== value) return false;
    }
    for (key in obj2) {
      value = obj2[key];
      if (obj1[key] !== value) return false;
    }
    return true;
  };

  arraysEqual = function(arr1, arr2) {
    var index, value, _len;
    if (arr1.length !== arr2.length) return false;
    for (index = 0, _len = arr1.length; index < _len; index++) {
      value = arr1[index];
      if (arr2[index] !== value) return false;
    }
    return true;
  };

  RouteNode = (function() {

    function RouteNode(_arg) {
      var name, nodeType, parent, _ref;
      _ref = _arg != null ? _arg : {}, name = _ref.name, nodeType = _ref.nodeType, parent = _ref.parent;
      this.name = name != null ? name : "";
      this.nodeType = nodeType != null ? nodeType : null;
      this.parent = parent != null ? parent : null;
      this.routeSettings = null;
      this.childLiterals = {};
      this.childVariable = null;
      this.bindings = [];
    }

    return RouteNode;

  })();

  RouteSettings = (function() {

    function RouteSettings(_arg) {
      var context, setup, teardown, _ref;
      _ref = _arg != null ? _arg : {}, setup = _ref.setup, teardown = _ref.teardown, context = _ref.context;
      this.setup = isFunction(setup) ? setup : (function() {});
      this.teardown = isFunction(teardown) ? teardown : (function() {});
      this.context = isObject(context) ? context : {};
    }

    return RouteSettings;

  })();

  RoutePath = (function() {

    function RoutePath(_arg) {
      var boundValues, node, _ref;
      _ref = _arg != null ? _arg : {}, node = _ref.node, boundValues = _ref.boundValues;
      this.node = node != null ? node : null;
      this.boundValues = boundValues != null ? boundValues : [];
    }

    RoutePath.prototype.getBindings = function() {
      var binding, bindings, index, _len, _ref;
      bindings = {};
      _ref = this.node.bindings;
      for (index = 0, _len = _ref.length; index < _len; index++) {
        binding = _ref[index];
        bindings[binding] = this.boundValues[index];
      }
      return bindings;
    };

    RoutePath.prototype.isEqual = function(path) {
      return (path != null) && this.node === path.node && arraysEqual(this.boundValues, path.boundValues);
    };

    RoutePath.prototype.isRoot = function() {
      return !(this.node.parent != null);
    };

    RoutePath.prototype.getParent = function() {
      var bindingCount, boundValues, _ref, _ref2;
      if (this.node == null) return null;
      bindingCount = (_ref = (_ref2 = this.node.parent) != null ? _ref2.bindings.length : void 0) != null ? _ref : 0;
      boundValues = this.boundValues.slice(0, bindingCount);
      return new RoutePath({
        node: this.node.parent,
        boundValues: boundValues
      });
    };

    RoutePath.prototype.getChild = function(targetPath) {
      var parent;
      while ((targetPath != null) && !this.isEqual(parent = targetPath.getParent())) {
        targetPath = parent;
      }
      return targetPath;
    };

    return RoutePath;

  })();

  NullPath = new RoutePath({
    node: null
  });

  NodeType = {
    Literal: 'Literal',
    Variable: 'Variable'
  };

  rootNode = currentPath = currentParameters = currentTargetPath = null;

  (resetGlobals = function() {
    rootNode = new RouteNode({
      name: "*"
    });
    currentPath = NullPath;
    currentParameters = {};
    return currentTargetPath = null;
  })();

  /*
  # Method: parseQueryString
  #	Used to parse and objectize a query string
  #
  # Arguments:
  #	queryString - The query string to split up into an object
  #
  # Returns:
  #	object - An object of the split apart query string
  */

  parseQueryString = function(queryString) {
    var key, piece, queryParameters, value, _i, _len, _ref, _ref2;
    queryString = isString(queryString) ? trim(queryString) : "";
    queryParameters = {};
    if (queryString !== "") {
      _ref = queryString.split("&");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        piece = _ref[_i];
        _ref2 = piece.split("=", 2), key = _ref2[0], value = _ref2[1];
        queryParameters[key] = value;
      }
    }
    return queryParameters;
  };

  /*
  # Method: getParentRouteString
  #	Gets the parent route sub-string of a route string
  #
  # Arguments:
  #	routeString - The route string to parse
  #
  # Returns:
  #	string - The parent route sub-string
  */

  getParentRouteString = function(routeString) {
    var closingBracketIndex;
    if (!startsWith(routeString, "[")) return "";
    closingBracketIndex = routeString.indexOf("]");
    return routeString.slice(1, (closingBracketIndex - 1) + 1 || 9e9);
  };

  /*
  # Method: getChildRouteString
  #	Gets the child route sub-string of a route string
  #
  # Arguments:
  #	routeString - The route string to parse
  #
  # Returns:
  #	string - The child route sub-string
  */

  getChildRouteString = function(routeString) {
    var closingBracketIndex;
    if (!startsWith(routeString, "[")) return routeString;
    closingBracketIndex = routeString.indexOf("]");
    return routeString.slice(closingBracketIndex + 1);
  };

  /*
  # Method: splitRouteString
  #	Splits a route string into its components.
  #
  # Arguments:
  #	routeString - The route string to split up into an array
  #
  # Returns:
  #	array - An array of the split apart route string
  #
  # Examples:
  #	splitRouteString("")
  #		-> []
  #	splitRouteString("/")
  #		-> [""]
  #	splitRouteString("/foo")
  #		-> ["foo"]
  #	splitRouteString("/foo/bar/")
  #		-> ["foo", "bar"]
  */

  splitRouteString = function(routeString) {
    if (routeString === "") return [];
    routeString = trimSlashes(routeString);
    return routeString.split('/');
  };

  getComponentType = function(routeStringComponent) {
    if (startsWith(routeStringComponent, ":")) return NodeType.Variable;
    return NodeType.Literal;
  };

  getComponentName = function(routeStringComponent) {
    switch (getComponentType(routeStringComponent)) {
      case NodeType.Literal:
        return routeStringComponent;
      case NodeType.Variable:
        return routeStringComponent.slice(1);
    }
  };

  /*
  # Method: addRoute
  #	Adds a new route node to the route tree, given a route string.
  #
  # Arguments:
  #	routeString - The route string to parse and add to the route tree.
  #	settings - The settings for the new route
  #
  # Returns:
  #	Route - The added route
  */

  addRoute = function(rootNode, routeString, settings) {
    var bindings, childRouteComponents, parentNode, parentRouteComponents, recur;
    parentRouteComponents = splitRouteString(getParentRouteString(routeString));
    childRouteComponents = splitRouteString(getChildRouteString(routeString));
    parentNode = rootNode;
    bindings = [];
    return (recur = function(currentNode, name) {
      var component, componentName, componentType, nextNode, onParentNode, _base, _ref, _ref2;
      component = null;
      onParentNode = false;
      nextNode = null;
      if (parentRouteComponents.length <= 0 && childRouteComponents.length <= 0) {
        currentNode.parent = parentNode;
        currentNode.bindings = bindings;
        return currentNode.routeSettings = new RouteSettings(settings);
      }
      if (parentRouteComponents.length > 0) {
        component = parentRouteComponents.shift();
        if (parentRouteComponents.length === 0) onParentNode = true;
      } else {
        component = childRouteComponents.shift();
      }
      componentType = getComponentType(component);
      componentName = getComponentName(component);
      name = "" + name + "/" + component;
      switch (componentType) {
        case NodeType.Literal:
          nextNode = (_ref = (_base = currentNode.childLiterals)[componentName]) != null ? _ref : _base[componentName] = new RouteNode({
            name: name,
            nodeType: componentType,
            parent: rootNode
          });
          break;
        case NodeType.Variable:
          nextNode = (_ref2 = currentNode.childVariable) != null ? _ref2 : currentNode.childVariable = new RouteNode({
            name: name,
            nodeType: componentType
          });
          bindings.push(componentName);
      }
      if (onParentNode) parentNode = nextNode;
      return recur(nextNode, name);
    })(rootNode, "");
  };

  /*
  # Method: findPath
  #	Finds a route in the route tree, given a URI.
  #
  # Arguments:
  #	rootNode - The root node of the route tree.
  #	uri - The uri to parse and match against the route tree.
  #
  # Returns:
  #	RoutePath
  #	node - The node that matches the URI
  #	boundValues - An ordered list of values bound to each variable in the URI
  */

  findPath = function(rootNode, uri) {
    var boundValues, recur, uriComponents;
    uriComponents = splitRouteString(uri);
    boundValues = [];
    return (recur = function(currentNode) {
      var component, result;
      if (uriComponents.length <= 0) {
        return new RoutePath({
          node: currentNode,
          boundValues: boundValues
        });
      }
      component = uriComponents.shift();
      if (currentNode.childLiterals[component] != null) {
        result = recur(currentNode.childLiterals[component]);
        if (result != null) return result;
      }
      if (currentNode.childVariable != null) {
        boundValues.push(component);
        result = recur(currentNode.childVariable);
        if (result != null) return result;
        boundValues.pop();
      }
      return null;
    })(rootNode);
  };

  /*
  # Method: findNearestCommonAncestor
  #	Finds the nearest common ancestor route node of two routes.
  #
  # Arguments:
  #	path1, path2 - The two paths to compare.
  #
  # Returns:
  #	RoutePath - The nearest common ancestor path of the two paths, or
  #	null if there is no common ancestor.
  */

  findNearestCommonAncestor = function(path1, path2) {
    var ancestor, ancestors, currentRoute, _i, _len;
    ancestors = [];
    currentRoute = path2;
    while (currentRoute != null) {
      ancestors.push(currentRoute);
      currentRoute = currentRoute.getParent();
    }
    currentRoute = path1;
    while (currentRoute != null) {
      for (_i = 0, _len = ancestors.length; _i < _len; _i++) {
        ancestor = ancestors[_i];
        if (currentRoute.isEqual(ancestor)) return currentRoute;
      }
      currentRoute = currentRoute.getParent();
    }
    return null;
  };

  /*
  # Method: step
  */

  step = function() {
    var ancestorPath, bindings, context, nextPath, recur, stepFunction, _ref, _ref2, _ref3, _ref4;
    if (currentTargetPath.isEqual(currentPath)) {
      console.log("RUN OBSERVABLES");
      return currentTargetPath = null;
    } else {
      ancestorPath = findNearestCommonAncestor(currentPath, currentTargetPath);
      nextPath = context = stepFunction = bindings = null;
      if (currentPath.isEqual(ancestorPath)) {
        nextPath = currentPath.getChild(currentTargetPath);
        _ref2 = (_ref = nextPath.node.routeSettings) != null ? _ref : {}, context = _ref2.context, stepFunction = _ref2.setup;
        bindings = nextPath.getBindings();
      } else {
        nextPath = currentPath.getParent();
        _ref4 = (_ref3 = currentPath.node.routeSettings) != null ? _ref3 : {}, context = _ref4.context, stepFunction = _ref4.teardown;
        bindings = currentPath.getBindings();
      }
      if (context == null) context = {};
      if (stepFunction == null) stepFunction = (function() {});
      recur = function() {
        currentPath = nextPath;
        return step();
      };
      if (stepFunction.length === 2) {
        return stepFunction.call(context, bindings, recur);
      } else {
        stepFunction.call(context, bindings);
        return recur();
      }
    }
  };

  /*
  # Class: Finch
  */

  Finch = {
    debug: true,
    /*
    	# Mathod: Finch.route
    	#	Used to setup a new route
    	#
    	# Arguments:
    	#	pattern - The pattern to add
    	#	callback - The callback to assign to the pattern
    */
    route: function(pattern, settings) {
      if (isFunction(settings)) {
        settings = {
          setup: settings
        };
      }
      if (!isObject(settings)) settings = {};
      if (!isString(pattern)) pattern = "";
      return addRoute(rootNode, pattern, settings);
    },
    /*
    	# Method: Finch.call
    	#
    	# Arguments:
    	#	route - The route to try and call
    */
    call: function(uri) {
      var bindings, newPath, previousTargetPath, queryParameters, queryString, _ref;
      if (!isString(uri)) uri = "/";
      if (uri === "") uri = "/";
      _ref = uri.split("?", 2), uri = _ref[0], queryString = _ref[1];
      newPath = findPath(rootNode, uri);
      if (newPath == null) return false;
      queryParameters = parseQueryString(queryString);
      bindings = newPath.getBindings();
      currentParameters = extend(queryParameters, bindings);
      previousTargetPath = currentTargetPath;
      currentTargetPath = newPath;
      if (previousTargetPath == null) step();
      return true;
    },
    /*
    	# Method: Finch.reset
    	#   Tears down the current stack and resets the routes
    	#
    	# Arguments:
    	#	none
    */
    reset: function() {
      currentTargetPath = NullPath;
      step();
      resetGlobals();
    }
  };

  /*
  if Finch.debug
  	Finch.private = {
  		# utility
  		isObject
  		isFunction
  		isArray
  		isString
  		isNumber
  		trim
  		trimSlashes
  		startsWith
  		endsWith
  		contains
  		extend
  		objectsEqual
  		arraysEqual
  
  		# constants
  		NullPath
  		NodeType
  
  		# classes
  		RouteSettings
  		RoutePath
  		RouteNode
  
  		#functions
  		parseQueryString
  		getParentRouteString
  		getChildRouteString
  		splitRouteString
  		getComponentType
  		getComponentName
  		addRoute
  		findPath
  		findNearestCommonAncestor
  
  		globals: -> return {
  			rootNode
  			currentPath
  			currentParameters
  		}
  	}
  */

  this.Finch = Finch;

}).call(this);
