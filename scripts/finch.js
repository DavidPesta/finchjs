/*
	Finch.js - Powerfully simple javascript routing
	by Rick Allen and Greg Smith

	Version 0.2.0
	Full source at https://github.com/stoodder/finchjs
	Copyright (c) 2011 RokkinCat, http://www.rokkincat.com

	MIT License, https://github.com/stoodder/finchjs/blob/master/LICENSE.md
	This file is generated by `cake build`, do not edit it by hand.
*/
(function() {
  var CurrentHash, CurrentParameters, CurrentPath, CurrentTargetPath, Finch, HashInterval, HashListening, NodeType, NullPath, ParameterObservable, RootNode, RouteNode, RoutePath, RouteSettings, addRoute, arraysEqual, contains, endsWith, extend, findNearestCommonAncestor, findPath, getChildRouteString, getComponentName, getComponentType, getParentRouteString, hashChangeListener, isArray, isFunction, isNumber, isObject, isString, objectsEqual, parseQueryString, peek, resetGlobals, splitRouteString, startsWith, step, stepSetup, stepTeardown, toArray, trim, trimSlashes,
    __slice = Array.prototype.slice;

  isObject = function(object) {
    return (typeof object) === (typeof {}) && object !== null;
  };

  isFunction = function(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
  };

  isArray = function(object) {
    return Object.prototype.toString.call(object) === "[object Array]";
  };

  isString = function(object) {
    return Object.prototype.toString.call(object) === "[object String]";
  };

  isNumber = function(object) {
    return Object.prototype.toString.call(object) === "[object Number]";
  };

  trim = function(str) {
    return str.replace(/^\s+/, '').replace(/\s+$/, '');
  };

  trimSlashes = function(str) {
    return str.replace(/^\/+/, '').replace(/\/+$/, '');
  };

  startsWith = function(haystack, needle) {
    return haystack.indexOf(needle) === 0;
  };

  endsWith = function(haystack, needle) {
    return haystack.indexOf(needle, haystack.length - needle.length) !== -1;
  };

  contains = function(haystack, needle) {
    return haystack.indexOf(needle) !== -1;
  };

  peek = function(arr) {
    return arr[arr.length - 1];
  };

  extend = function(obj, extender) {
    var key, value;
    if (!isObject(obj)) obj = {};
    if (!isObject(extender)) extender = {};
    for (key in extender) {
      value = extender[key];
      obj[key] = value;
    }
    return obj;
  };

  objectsEqual = function(obj1, obj2) {
    var key, value;
    for (key in obj1) {
      value = obj1[key];
      if (obj2[key] !== value) return false;
    }
    for (key in obj2) {
      value = obj2[key];
      if (obj1[key] !== value) return false;
    }
    return true;
  };

  arraysEqual = function(arr1, arr2) {
    var index, value, _len;
    if (arr1.length !== arr2.length) return false;
    for (index = 0, _len = arr1.length; index < _len; index++) {
      value = arr1[index];
      if (arr2[index] !== value) return false;
    }
    return true;
  };

  toArray = function(obj) {
    var arr, key, value, _ref;
    arr = [];
    _ref = obj != null ? obj : {};
    for (key in _ref) {
      value = _ref[key];
      arr[arr.length] = value;
    }
    return arr;
  };

  RouteNode = (function() {

    function RouteNode(_arg) {
      var name, nodeType, parent, _ref;
      _ref = _arg != null ? _arg : {}, name = _ref.name, nodeType = _ref.nodeType, parent = _ref.parent;
      this.name = name != null ? name : "";
      this.nodeType = nodeType != null ? nodeType : null;
      this.parent = parent != null ? parent : null;
      this.routeSettings = null;
      this.childLiterals = {};
      this.childVariable = null;
      this.bindings = [];
    }

    return RouteNode;

  })();

  RouteSettings = (function() {

    function RouteSettings(_arg) {
      var context, setup, teardown, _ref;
      _ref = _arg != null ? _arg : {}, setup = _ref.setup, teardown = _ref.teardown, context = _ref.context;
      this.setup = isFunction(setup) ? setup : (function() {});
      this.teardown = isFunction(teardown) ? teardown : (function() {});
      this.context = isObject(context) ? context : {};
    }

    return RouteSettings;

  })();

  RoutePath = (function() {

    function RoutePath(_arg) {
      var boundValues, node, parameterObservables, _ref;
      _ref = _arg != null ? _arg : {}, node = _ref.node, boundValues = _ref.boundValues, parameterObservables = _ref.parameterObservables;
      this.node = node != null ? node : null;
      this.boundValues = boundValues != null ? boundValues : [];
      this.parameterObservables = parameterObservables != null ? parameterObservables : [];
    }

    RoutePath.prototype.getBindings = function() {
      var binding, bindings, index, _len, _ref;
      bindings = {};
      _ref = this.node.bindings;
      for (index = 0, _len = _ref.length; index < _len; index++) {
        binding = _ref[index];
        bindings[binding] = this.boundValues[index];
      }
      return bindings;
    };

    RoutePath.prototype.isEqual = function(path) {
      return (path != null) && this.node === path.node && arraysEqual(this.boundValues, path.boundValues);
    };

    RoutePath.prototype.isRoot = function() {
      return !(this.node.parent != null);
    };

    RoutePath.prototype.getParent = function() {
      var bindingCount, boundValues, parameterObservables, _ref, _ref2;
      if (this.node == null) return null;
      bindingCount = (_ref = (_ref2 = this.node.parent) != null ? _ref2.bindings.length : void 0) != null ? _ref : 0;
      boundValues = this.boundValues.slice(0, bindingCount);
      parameterObservables = this.parameterObservables.slice(0, -1);
      return new RoutePath({
        node: this.node.parent,
        boundValues: boundValues,
        parameterObservables: parameterObservables
      });
    };

    RoutePath.prototype.getChild = function(targetPath) {
      var parent;
      while ((targetPath != null) && !this.isEqual(parent = targetPath.getParent())) {
        targetPath = parent;
      }
      targetPath.parameterObservables = this.parameterObservables.slice(0);
      targetPath.parameterObservables.push([]);
      return targetPath;
    };

    return RoutePath;

  })();

  ParameterObservable = (function() {

    function ParameterObservable(callback) {
      var _this = this;
      this.callback = callback;
      if (!isFunction(this.callback)) this.callback = (function() {});
      this.dependencies = [];
      this.parameterAccessor = function(key) {
        if (!contains(_this.dependencies, key)) _this.dependencies.push(key);
        return CurrentParameters[key];
      };
    }

    ParameterObservable.prototype.resetDependencies = function() {
      return this.dependencies = [];
    };

    ParameterObservable.prototype.trigger = function() {
      this.resetDependencies();
      return this.callback(this.parameterAccessor);
    };

    return ParameterObservable;

  })();

  NullPath = new RoutePath({
    node: null
  });

  NodeType = {
    Literal: 'Literal',
    Variable: 'Variable'
  };

  parseQueryString = function(queryString) {
    var key, piece, queryParameters, value, _i, _len, _ref, _ref2;
    queryString = isString(queryString) ? trim(queryString) : "";
    queryParameters = {};
    if (queryString !== "") {
      _ref = queryString.split("&");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        piece = _ref[_i];
        _ref2 = piece.split("=", 2), key = _ref2[0], value = _ref2[1];
        queryParameters[key] = value;
      }
    }
    return queryParameters;
  };

  getParentRouteString = function(routeString) {
    var closingBracketIndex;
    if (!startsWith(routeString, "[")) return "";
    closingBracketIndex = routeString.indexOf("]");
    return routeString.slice(1, (closingBracketIndex - 1) + 1 || 9e9);
  };

  getChildRouteString = function(routeString) {
    var closingBracketIndex;
    if (!startsWith(routeString, "[")) return routeString;
    closingBracketIndex = routeString.indexOf("]");
    return routeString.slice(closingBracketIndex + 1);
  };

  splitRouteString = function(routeString) {
    if (routeString === "") return [];
    routeString = trimSlashes(routeString);
    return routeString.split('/');
  };

  getComponentType = function(routeStringComponent) {
    if (startsWith(routeStringComponent, ":")) return NodeType.Variable;
    return NodeType.Literal;
  };

  getComponentName = function(routeStringComponent) {
    switch (getComponentType(routeStringComponent)) {
      case NodeType.Literal:
        return routeStringComponent;
      case NodeType.Variable:
        return routeStringComponent.slice(1);
    }
  };

  addRoute = function(rootNode, routeString, settings) {
    var bindings, childRouteComponents, parentNode, parentRouteComponents, recur;
    parentRouteComponents = splitRouteString(getParentRouteString(routeString));
    childRouteComponents = splitRouteString(getChildRouteString(routeString));
    parentNode = rootNode;
    bindings = [];
    return (recur = function(currentNode, name) {
      var component, componentName, componentType, nextNode, onParentNode, _base, _ref, _ref2;
      component = null;
      onParentNode = false;
      nextNode = null;
      if (parentRouteComponents.length <= 0 && childRouteComponents.length <= 0) {
        currentNode.parent = parentNode;
        currentNode.bindings = bindings;
        return currentNode.routeSettings = new RouteSettings(settings);
      }
      if (parentRouteComponents.length > 0) {
        component = parentRouteComponents.shift();
        if (parentRouteComponents.length === 0) onParentNode = true;
      } else {
        component = childRouteComponents.shift();
      }
      componentType = getComponentType(component);
      componentName = getComponentName(component);
      name = "" + name + "/" + component;
      switch (componentType) {
        case NodeType.Literal:
          nextNode = (_ref = (_base = currentNode.childLiterals)[componentName]) != null ? _ref : _base[componentName] = new RouteNode({
            name: name,
            nodeType: componentType,
            parent: rootNode
          });
          break;
        case NodeType.Variable:
          nextNode = (_ref2 = currentNode.childVariable) != null ? _ref2 : currentNode.childVariable = new RouteNode({
            name: name,
            nodeType: componentType
          });
          bindings.push(componentName);
      }
      if (onParentNode) parentNode = nextNode;
      return recur(nextNode, name);
    })(rootNode, "");
  };

  findPath = function(rootNode, uri) {
    var boundValues, recur, uriComponents;
    uriComponents = splitRouteString(uri);
    boundValues = [];
    return (recur = function(currentNode) {
      var component, result;
      if (uriComponents.length <= 0) {
        return new RoutePath({
          node: currentNode,
          boundValues: boundValues
        });
      }
      component = uriComponents.shift();
      if (currentNode.childLiterals[component] != null) {
        result = recur(currentNode.childLiterals[component]);
        if (result != null) return result;
      }
      if (currentNode.childVariable != null) {
        boundValues.push(component);
        result = recur(currentNode.childVariable);
        if (result != null) return result;
        boundValues.pop();
      }
      return null;
    })(rootNode);
  };

  findNearestCommonAncestor = function(path1, path2) {
    var ancestor, ancestors, currentRoute, _i, _len;
    ancestors = [];
    currentRoute = path2;
    while (currentRoute != null) {
      ancestors.push(currentRoute);
      currentRoute = currentRoute.getParent();
    }
    currentRoute = path1;
    while (currentRoute != null) {
      for (_i = 0, _len = ancestors.length; _i < _len; _i++) {
        ancestor = ancestors[_i];
        if (currentRoute.isEqual(ancestor)) return currentRoute;
      }
      currentRoute = currentRoute.getParent();
    }
    return null;
  };

  RootNode = CurrentPath = CurrentParameters = CurrentTargetPath = null;

  HashInterval = CurrentHash = null;

  HashListening = false;

  (resetGlobals = function() {
    RootNode = new RouteNode({
      name: "*"
    });
    CurrentPath = NullPath;
    CurrentParameters = {};
    return CurrentTargetPath = null;
  })();

  step = function() {
    var ancestorPath, observable, observableList, _i, _j, _len, _len2, _ref;
    if (CurrentTargetPath.isEqual(CurrentPath)) {
      _ref = CurrentPath.parameterObservables;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        observableList = _ref[_i];
        for (_j = 0, _len2 = observableList.length; _j < _len2; _j++) {
          observable = observableList[_j];
          observable.trigger();
        }
      }
      return CurrentTargetPath = null;
    } else {
      ancestorPath = findNearestCommonAncestor(CurrentPath, CurrentTargetPath);
      if (CurrentPath.isEqual(ancestorPath)) {
        return stepSetup();
      } else {
        return stepTeardown();
      }
    }
  };

  stepSetup = function() {
    var bindings, context, recur, setup, _ref, _ref2;
    CurrentPath = CurrentPath.getChild(CurrentTargetPath);
    _ref2 = (_ref = CurrentPath.node.routeSettings) != null ? _ref : {}, context = _ref2.context, setup = _ref2.setup;
    if (context == null) context = {};
    if (setup == null) setup = (function() {});
    bindings = CurrentPath.getBindings();
    recur = function() {
      return step();
    };
    if (setup.length === 2) {
      return setup.call(context, bindings, recur);
    } else {
      setup.call(context, bindings);
      return recur();
    }
  };

  stepTeardown = function() {
    var bindings, context, recur, teardown, _ref, _ref2;
    _ref2 = (_ref = CurrentPath.node.routeSettings) != null ? _ref : {}, context = _ref2.context, teardown = _ref2.teardown;
    if (context == null) context = {};
    if (teardown == null) teardown = (function() {});
    bindings = CurrentPath.getBindings();
    recur = function() {
      CurrentPath = CurrentPath.getParent();
      return step();
    };
    if (teardown.length === 2) {
      return teardown.call(context, bindings, recur);
    } else {
      teardown.call(context, bindings);
      return recur();
    }
  };

  hashChangeListener = function(event) {
    var hash;
    hash = window.location.hash;
    if (startsWith(hash, "#")) hash = hash.slice(1);
    hash = unescape(hash);
    if (hash !== CurrentHash) {
      Finch.call(hash);
      return CurrentHash = hash;
    }
  };

  Finch = {
    debug: true,
    route: function(pattern, settings) {
      if (isFunction(settings)) {
        settings = {
          setup: settings
        };
      }
      if (!isObject(settings)) settings = {};
      if (!isString(pattern)) pattern = "";
      return addRoute(RootNode, pattern, settings);
    },
    call: function(uri) {
      var bindings, newPath, previousTargetPath, queryParameters, queryString, _ref;
      if (!isString(uri)) uri = "/";
      if (uri === "") uri = "/";
      _ref = uri.split("?", 2), uri = _ref[0], queryString = _ref[1];
      newPath = findPath(RootNode, uri);
      if (newPath == null) return false;
      queryParameters = parseQueryString(queryString);
      bindings = newPath.getBindings();
      CurrentParameters = extend(queryParameters, bindings);
      previousTargetPath = CurrentTargetPath;
      CurrentTargetPath = newPath;
      if (previousTargetPath == null) step();
      return true;
    },
    observe: function() {
      var args, callback, keys, observable;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length > 2) {
        callback = args.pop();
        return Finch.observe(toArray(args), callback);
      } else if (args.length === 2) {
        keys = args[0], callback = args[1];
        if (isString(keys)) keys = [keys];
        if (!isArray(keys)) keys = [];
        if (!isFunction(callback)) callback = (function() {});
        return Finch.observe(function(params) {
          var key, values;
          values = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = keys.length; _i < _len; _i++) {
              key = keys[_i];
              _results.push(params(key));
            }
            return _results;
          })();
          return callback.apply(null, values);
        });
      } else {
        callback = isFunction(args[0]) ? args[0] : (function() {});
        observable = new ParameterObservable(callback);
        return peek(CurrentPath.parameterObservables).push(observable);
      }
    },
    listen: function() {
      if (!HashListening) {
        if ("onhashchange" in window) {
          if (isFunction(window.addEventListener)) {
            window.addEventListener("hashchange", hashChangeListener, true);
            HashListening = true;
          } else if (isFunction(window.attachEvent)) {
            window.attachEvent("hashchange", hashChangeListener);
            HashListening = true;
          }
        }
        if (!HashListening) {
          HashInterval = setInterval(hashChangeListener, 33);
          HashListening = true;
        }
        hashChangeListener();
      }
      return HashListening;
    },
    ignore: function() {
      if (HashListening) {
        if (HashInterval !== null) {
          clearInterval(HashInterval);
          HashInterval = null;
          HashListening = false;
        } else if ("onhashchange" in window) {
          if (isFunction(window.removeEventListener)) {
            window.removeEventListener("hashchange", hashChangeListener, true);
            HashListening = false;
          } else if (isFunction(window.detachEvent)) {
            window.detachEvent("hashchange", hashChangeListener);
            HashListening = false;
          }
        }
      }
      return !HashListening;
    },
    navigate: function(uri, queryParams) {
      var currentQueryParams, currentQueryString, key, queryString, value, _ref, _ref2;
      if (isObject(uri)) {
        queryParams = uri;
        uri = null;
        currentQueryString = (_ref = window.location.hash.split("?", 2)[1]) != null ? _ref : "";
        currentQueryParams = parseQueryString(currentQueryString);
        for (key in currentQueryParams) {
          value = currentQueryParams[key];
          currentQueryParams[unescape(key)] = unescape(value);
        }
        queryParams = extend(currentQueryParams, queryParams);
      } else {
        if (!isString(uri)) uri = null;
        if (!isObject(queryParams)) queryParams = {};
      }
      queryString = ((function() {
        var _results;
        _results = [];
        for (key in queryParams) {
          value = queryParams[key];
          _results.push(escape(key) + "=" + escape(value));
        }
        return _results;
      })()).join("&");
      if (uri === null) {
        uri = (_ref2 = window.location.hash.split("?", 2)[0]) != null ? _ref2 : "";
        if (uri.slice(0, 1) === "#") uri = uri.slice(1);
      }
      uri = escape(uri);
      if (queryString.length > 0) {
        uri += uri.indexOf("?") > -1 ? "&" : "?";
        uri += queryString;
      }
      return window.location.hash = uri;
    },
    reset: function() {
      CurrentTargetPath = NullPath;
      step();
      resetGlobals();
    }
  };

  /*
  if Finch.debug
  	Finch.private = {
  		# utility
  		isObject
  		isFunction
  		isArray
  		isString
  		isNumber
  		trim
  		trimSlashes
  		startsWith
  		endsWith
  		contains
  		extend
  		objectsEqual
  		arraysEqual
  
  		# constants
  		NullPath
  		NodeType
  
  		# classes
  		RouteSettings
  		RoutePath
  		RouteNode
  
  		#functions
  		parseQueryString
  		getParentRouteString
  		getChildRouteString
  		splitRouteString
  		getComponentType
  		getComponentName
  		addRoute
  		findPath
  		findNearestCommonAncestor
  
  		globals: -> return {
  			RootNode
  			CurrentPath
  			CurrentParameters
  		}
  	}
  */

  this.Finch = Finch;

}).call(this);
