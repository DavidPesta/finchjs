/*
	Finch.js - Powerfully simple javascript routing
	by Rick Allen and Greg Smith

	Version 0.2.0
	Full source at https://github.com/stoodder/finchjs
	Copyright (c) 2011 RokkinCat, http://www.rokkincat.com

	MIT License, https://github.com/stoodder/finchjs/blob/master/LICENSE.md
	This file is generated by `cake build`, do not edit it by hand.
*/
(function() {
  var CurrentParameters, CurrentPath, CurrentTargetPath, Finch, NodeType, NullPath, ParameterObservable, RootNode, RouteNode, RoutePath, RouteSettings, addRoute, arraysEqual, contains, currentHash, endsWith, extend, findNearestCommonAncestor, findPath, getChildRouteString, getComponentName, getComponentType, getParentRouteString, hashChange, hashInterval, hashListening, isArray, isFunction, isNumber, isObject, isString, objectsEqual, parseQueryString, peek, resetGlobals, splitRouteString, startsWith, step, stepSetup, stepTeardown, trim, trimSlashes,
    __slice = Array.prototype.slice;

  isObject = function(object) {
    return typeof object === typeof {};
  };

  isFunction = function(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
  };

  isArray = function(object) {
    return Object.prototype.toString.call(object) === "[object Array]";
  };

  isString = function(object) {
    return Object.prototype.toString.call(object) === "[object String]";
  };

  isNumber = function(object) {
    return Object.prototype.toString.call(object) === "[object Number]";
  };

  trim = function(str) {
    return str.replace(/^\s+/, '').replace(/\s+$/, '');
  };

  trimSlashes = function(str) {
    return str.replace(/^\/+/, '').replace(/\/+$/, '');
  };

  startsWith = function(haystack, needle) {
    return haystack.indexOf(needle) === 0;
  };

  endsWith = function(haystack, needle) {
    return haystack.indexOf(needle, haystack.length - needle.length) !== -1;
  };

  contains = function(haystack, needle) {
    return haystack.indexOf(needle) !== -1;
  };

  peek = function(arr) {
    return arr[arr.length - 1];
  };

  extend = function(obj, extender) {
    var key, value;
    if (!isObject(obj)) obj = {};
    if (!isObject(extender)) extender = {};
    for (key in extender) {
      value = extender[key];
      obj[key] = value;
    }
    return obj;
  };

  objectsEqual = function(obj1, obj2) {
    var key, value;
    for (key in obj1) {
      value = obj1[key];
      if (obj2[key] !== value) return false;
    }
    for (key in obj2) {
      value = obj2[key];
      if (obj1[key] !== value) return false;
    }
    return true;
  };

  arraysEqual = function(arr1, arr2) {
    var index, value, _len;
    if (arr1.length !== arr2.length) return false;
    for (index = 0, _len = arr1.length; index < _len; index++) {
      value = arr1[index];
      if (arr2[index] !== value) return false;
    }
    return true;
  };

  RouteNode = (function() {

    function RouteNode(_arg) {
      var name, nodeType, parent, _ref;
      _ref = _arg != null ? _arg : {}, name = _ref.name, nodeType = _ref.nodeType, parent = _ref.parent;
      this.name = name != null ? name : "";
      this.nodeType = nodeType != null ? nodeType : null;
      this.parent = parent != null ? parent : null;
      this.routeSettings = null;
      this.childLiterals = {};
      this.childVariable = null;
      this.bindings = [];
    }

    return RouteNode;

  })();

  RouteSettings = (function() {

    function RouteSettings(_arg) {
      var context, setup, teardown, _ref;
      _ref = _arg != null ? _arg : {}, setup = _ref.setup, teardown = _ref.teardown, context = _ref.context;
      this.setup = isFunction(setup) ? setup : (function() {});
      this.teardown = isFunction(teardown) ? teardown : (function() {});
      this.context = isObject(context) ? context : {};
    }

    return RouteSettings;

  })();

  RoutePath = (function() {

    function RoutePath(_arg) {
      var boundValues, node, parameterObservables, _ref;
      _ref = _arg != null ? _arg : {}, node = _ref.node, boundValues = _ref.boundValues, parameterObservables = _ref.parameterObservables;
      this.node = node != null ? node : null;
      this.boundValues = boundValues != null ? boundValues : [];
      this.parameterObservables = parameterObservables != null ? parameterObservables : [];
    }

    RoutePath.prototype.getBindings = function() {
      var binding, bindings, index, _len, _ref;
      bindings = {};
      _ref = this.node.bindings;
      for (index = 0, _len = _ref.length; index < _len; index++) {
        binding = _ref[index];
        bindings[binding] = this.boundValues[index];
      }
      return bindings;
    };

    RoutePath.prototype.isEqual = function(path) {
      return (path != null) && this.node === path.node && arraysEqual(this.boundValues, path.boundValues);
    };

    RoutePath.prototype.isRoot = function() {
      return !(this.node.parent != null);
    };

    RoutePath.prototype.getParent = function() {
      var bindingCount, boundValues, parameterObservables, _ref, _ref2;
      if (this.node == null) return null;
      bindingCount = (_ref = (_ref2 = this.node.parent) != null ? _ref2.bindings.length : void 0) != null ? _ref : 0;
      boundValues = this.boundValues.slice(0, bindingCount);
      parameterObservables = this.parameterObservables.slice(0, -1);
      return new RoutePath({
        node: this.node.parent,
        boundValues: boundValues,
        parameterObservables: parameterObservables
      });
    };

    RoutePath.prototype.getChild = function(targetPath) {
      var parent;
      while ((targetPath != null) && !this.isEqual(parent = targetPath.getParent())) {
        targetPath = parent;
      }
      targetPath.parameterObservables = this.parameterObservables.slice(0);
      targetPath.parameterObservables.push([]);
      return targetPath;
    };

    return RoutePath;

  })();

  ParameterObservable = (function() {

    function ParameterObservable(callback) {
      var _this = this;
      this.callback = callback;
      if (!isFunction(this.callback)) this.callback = (function() {});
      this.dependencies = [];
      this.parameterAccessor = function(key) {
        if (!contains(_this.dependencies, key)) _this.dependencies.push(key);
        return CurrentParameters[key];
      };
    }

    ParameterObservable.prototype.resetDependencies = function() {
      return this.dependencies = [];
    };

    ParameterObservable.prototype.trigger = function() {
      this.resetDependencies();
      return this.callback(this.parameterAccessor);
    };

    return ParameterObservable;

  })();

  NullPath = new RoutePath({
    node: null
  });

  NodeType = {
    Literal: 'Literal',
    Variable: 'Variable'
  };

  hashInterval = currentHash = null;

  hashListening = false;

  /*
  # Method: parseQueryString
  #	Used to parse and objectize a query string
  #
  # Arguments:
  #	queryString - The query string to split up into an object
  #
  # Returns:
  #	object - An object of the split apart query string
  */

  parseQueryString = function(queryString) {
    var key, piece, queryParameters, value, _i, _len, _ref, _ref2;
    queryString = isString(queryString) ? trim(queryString) : "";
    queryParameters = {};
    if (queryString !== "") {
      _ref = queryString.split("&");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        piece = _ref[_i];
        _ref2 = piece.split("=", 2), key = _ref2[0], value = _ref2[1];
        queryParameters[key] = value;
      }
    }
    return queryParameters;
  };

  /*
  # Method: getParentRouteString
  #	Gets the parent route sub-string of a route string
  #
  # Arguments:
  #	routeString - The route string to parse
  #
  # Returns:
  #	string - The parent route sub-string
  */

  getParentRouteString = function(routeString) {
    var closingBracketIndex;
    if (!startsWith(routeString, "[")) return "";
    closingBracketIndex = routeString.indexOf("]");
    return routeString.slice(1, (closingBracketIndex - 1) + 1 || 9e9);
  };

  /*
  # Method: getChildRouteString
  #	Gets the child route sub-string of a route string
  #
  # Arguments:
  #	routeString - The route string to parse
  #
  # Returns:
  #	string - The child route sub-string
  */

  getChildRouteString = function(routeString) {
    var closingBracketIndex;
    if (!startsWith(routeString, "[")) return routeString;
    closingBracketIndex = routeString.indexOf("]");
    return routeString.slice(closingBracketIndex + 1);
  };

  /*
  # Method: splitRouteString
  #	Splits a route string into its components.
  #
  # Arguments:
  #	routeString - The route string to split up into an array
  #
  # Returns:
  #	array - An array of the split apart route string
  #
  # Examples:
  #	splitRouteString("")
  #		-> []
  #	splitRouteString("/")
  #		-> [""]
  #	splitRouteString("/foo")
  #		-> ["foo"]
  #	splitRouteString("/foo/bar/")
  #		-> ["foo", "bar"]
  */

  splitRouteString = function(routeString) {
    if (routeString === "") return [];
    routeString = trimSlashes(routeString);
    return routeString.split('/');
  };

  getComponentType = function(routeStringComponent) {
    if (startsWith(routeStringComponent, ":")) return NodeType.Variable;
    return NodeType.Literal;
  };

  getComponentName = function(routeStringComponent) {
    switch (getComponentType(routeStringComponent)) {
      case NodeType.Literal:
        return routeStringComponent;
      case NodeType.Variable:
        return routeStringComponent.slice(1);
    }
  };

  /*
  # Method: addRoute
  #	Adds a new route node to the route tree, given a route string.
  #
  # Arguments:
  #	routeString - The route string to parse and add to the route tree.
  #	settings - The settings for the new route
  #
  # Returns:
  #	Route - The added route
  */

  addRoute = function(rootNode, routeString, settings) {
    var bindings, childRouteComponents, parentNode, parentRouteComponents, recur;
    parentRouteComponents = splitRouteString(getParentRouteString(routeString));
    childRouteComponents = splitRouteString(getChildRouteString(routeString));
    parentNode = rootNode;
    bindings = [];
    return (recur = function(currentNode, name) {
      var component, componentName, componentType, nextNode, onParentNode, _base, _ref, _ref2;
      component = null;
      onParentNode = false;
      nextNode = null;
      if (parentRouteComponents.length <= 0 && childRouteComponents.length <= 0) {
        currentNode.parent = parentNode;
        currentNode.bindings = bindings;
        return currentNode.routeSettings = new RouteSettings(settings);
      }
      if (parentRouteComponents.length > 0) {
        component = parentRouteComponents.shift();
        if (parentRouteComponents.length === 0) onParentNode = true;
      } else {
        component = childRouteComponents.shift();
      }
      componentType = getComponentType(component);
      componentName = getComponentName(component);
      name = "" + name + "/" + component;
      switch (componentType) {
        case NodeType.Literal:
          nextNode = (_ref = (_base = currentNode.childLiterals)[componentName]) != null ? _ref : _base[componentName] = new RouteNode({
            name: name,
            nodeType: componentType,
            parent: rootNode
          });
          break;
        case NodeType.Variable:
          nextNode = (_ref2 = currentNode.childVariable) != null ? _ref2 : currentNode.childVariable = new RouteNode({
            name: name,
            nodeType: componentType
          });
          bindings.push(componentName);
      }
      if (onParentNode) parentNode = nextNode;
      return recur(nextNode, name);
    })(rootNode, "");
  };

  /*
  # Method: findPath
  #	Finds a route in the route tree, given a URI.
  #
  # Arguments:
  #	rootNode - The root node of the route tree.
  #	uri - The uri to parse and match against the route tree.
  #
  # Returns:
  #	RoutePath
  #	node - The node that matches the URI
  #	boundValues - An ordered list of values bound to each variable in the URI
  */

  findPath = function(rootNode, uri) {
    var boundValues, recur, uriComponents;
    uriComponents = splitRouteString(uri);
    boundValues = [];
    return (recur = function(currentNode) {
      var component, result;
      if (uriComponents.length <= 0) {
        return new RoutePath({
          node: currentNode,
          boundValues: boundValues
        });
      }
      component = uriComponents.shift();
      if (currentNode.childLiterals[component] != null) {
        result = recur(currentNode.childLiterals[component]);
        if (result != null) return result;
      }
      if (currentNode.childVariable != null) {
        boundValues.push(component);
        result = recur(currentNode.childVariable);
        if (result != null) return result;
        boundValues.pop();
      }
      return null;
    })(rootNode);
  };

  /*
  # Method: findNearestCommonAncestor
  #	Finds the nearest common ancestor route node of two routes.
  #
  # Arguments:
  #	path1, path2 - The two paths to compare.
  #
  # Returns:
  #	RoutePath - The nearest common ancestor path of the two paths, or
  #	null if there is no common ancestor.
  */

  findNearestCommonAncestor = function(path1, path2) {
    var ancestor, ancestors, currentRoute, _i, _len;
    ancestors = [];
    currentRoute = path2;
    while (currentRoute != null) {
      ancestors.push(currentRoute);
      currentRoute = currentRoute.getParent();
    }
    currentRoute = path1;
    while (currentRoute != null) {
      for (_i = 0, _len = ancestors.length; _i < _len; _i++) {
        ancestor = ancestors[_i];
        if (currentRoute.isEqual(ancestor)) return currentRoute;
      }
      currentRoute = currentRoute.getParent();
    }
    return null;
  };

  /*
  # Globals
  */

  RootNode = CurrentPath = CurrentParameters = CurrentTargetPath = null;

  (resetGlobals = function() {
    RootNode = new RouteNode({
      name: "*"
    });
    CurrentPath = NullPath;
    CurrentParameters = {};
    return CurrentTargetPath = null;
  })();

  /*
  # Method: step
  */

  step = function() {
    var ancestorPath, observable, observableList, _i, _j, _len, _len2, _ref;
    if (CurrentTargetPath.isEqual(CurrentPath)) {
      _ref = CurrentPath.parameterObservables;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        observableList = _ref[_i];
        for (_j = 0, _len2 = observableList.length; _j < _len2; _j++) {
          observable = observableList[_j];
          observable.trigger();
        }
      }
      return CurrentTargetPath = null;
    } else {
      ancestorPath = findNearestCommonAncestor(CurrentPath, CurrentTargetPath);
      if (CurrentPath.isEqual(ancestorPath)) {
        return stepSetup();
      } else {
        return stepTeardown();
      }
    }
  };

  stepSetup = function() {
    var bindings, context, recur, setup, _ref, _ref2;
    CurrentPath = CurrentPath.getChild(CurrentTargetPath);
    _ref2 = (_ref = CurrentPath.node.routeSettings) != null ? _ref : {}, context = _ref2.context, setup = _ref2.setup;
    if (context == null) context = {};
    if (setup == null) setup = (function() {});
    bindings = CurrentPath.getBindings();
    recur = function() {
      return step();
    };
    if (setup.length === 2) {
      return setup.call(context, bindings, recur);
    } else {
      setup.call(context, bindings);
      return recur();
    }
  };

  stepTeardown = function() {
    var bindings, context, recur, teardown, _ref, _ref2;
    _ref2 = (_ref = CurrentPath.node.routeSettings) != null ? _ref : {}, context = _ref2.context, teardown = _ref2.teardown;
    if (context == null) context = {};
    if (teardown == null) teardown = (function() {});
    bindings = CurrentPath.getBindings();
    recur = function() {
      CurrentPath = CurrentPath.getParent();
      return step();
    };
    if (teardown.length === 2) {
      return teardown.call(context, bindings, recur);
    } else {
      teardown.call(context, bindings);
      return recur();
    }
  };

  /*
  # Method: hashChange
  #	Used to respond to hash changes
  */

  hashChange = function(event) {
    var hash, url, urlSplit;
    hash = "";
    if ("hash" in window.location) {
      hash = window.location.hash;
      if (startsWith(hash, "#")) hash = hash.slice(1);
    } else {
      url = window.location.href;
      urlSplit = url.split("#", 2);
      hash = (urlSplit.length === 2 ? urlSplit[1] : "");
    }
    if (hash !== currentHash) {
      Finch.call(hash);
      return currentHash = hash;
    }
  };

  /*
  # Class: Finch
  */

  Finch = {
    debug: true,
    /*
    	# Mathod: Finch.route
    	#	Used to setup a new route
    	#
    	# Arguments:
    	#	pattern - The pattern to add
    	#	callback - The callback to assign to the pattern
    */
    route: function(pattern, settings) {
      if (isFunction(settings)) {
        settings = {
          setup: settings
        };
      }
      if (!isObject(settings)) settings = {};
      if (!isString(pattern)) pattern = "";
      return addRoute(RootNode, pattern, settings);
    },
    /*
    	# Method: Finch.call
    	#
    	# Arguments:
    	#	route - The route to try and call
    */
    call: function(uri) {
      var bindings, newPath, previousTargetPath, queryParameters, queryString, _ref;
      if (!isString(uri)) uri = "/";
      if (uri === "") uri = "/";
      _ref = uri.split("?", 2), uri = _ref[0], queryString = _ref[1];
      newPath = findPath(RootNode, uri);
      if (newPath == null) return false;
      queryParameters = parseQueryString(queryString);
      bindings = newPath.getBindings();
      CurrentParameters = extend(queryParameters, bindings);
      previousTargetPath = CurrentTargetPath;
      CurrentTargetPath = newPath;
      if (previousTargetPath == null) step();
      return true;
    },
    /*
    	# Method: Finch.observe
    	#	Used to set up observers on the query string.
    	#
    	# Form 1:
    	# Arguments:
    	#	keys - An array of param keys
    	#	callback(keys...) - A callback function to execute with the values bound to each key in order.
    	#
    	# Form 2:
    	# Arguments:
    	#	callback(params) - A callback function to execute with a params accessor.
    */
    observe: function() {
      var args, callback, keys, observable;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 2) {
        keys = args[0], callback = args[1];
        if (!isArray(keys)) keys = [];
        if (!isFunction(callback)) callback = (function() {});
        return Finch.observe(function(params) {
          var key, values;
          values = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = keys.length; _i < _len; _i++) {
              key = keys[_i];
              _results.push(params(key));
            }
            return _results;
          })();
          return callback.apply(null, values);
        });
      }
      callback = args[0];
      if (!isFunction(callback)) callback = (function() {});
      observable = new ParameterObservable(callback);
      return peek(CurrentPath.parameterObservables).push(observable);
    },
    /*
    	# Method: Finch.listen
    	#	Used to listen to changes in the window hash, will respond with Finch.call
    	#
    	# Returns:
    	#	boolean - Is Finch listening?
    */
    listen: function() {
      if (!hashListening) {
        if ("onhashchange" in window) {
          if (isFunction(window.addEventListener)) {
            window.addEventListener("hashchange", hashChange, true);
            hashListening = true;
          } else if (isFunction(window.attachEvent)) {
            window.attachEvent("hashchange", hashChange);
            hashListening = true;
          }
        } else {
          hashInterval = setInterval(hashChange, 33);
          hashListening = true;
        }
        hashChange();
      }
      return hashListening;
    },
    /*
    	# Method: Finch.ignore
    	#	Used to stop listening to changes in the hash
    	#
    	# Returns:
    	#	boolean - Is Finch done listening?
    */
    ignore: function() {
      if (hashListening) {
        if (hashInterval !== null) {
          clearInterval(hashInterval);
          hashInterval = null;
          hashListening = false;
        } else if ("onhashchange" in window) {
          if (isFunction(window.removeEventListener)) {
            window.removeEventListener("hashchange", hashChange, true);
            hashListening = false;
          } else if (isFunction(window.detachEvent)) {
            window.detachEvent("hashchange", hashChange);
            hashListening = false;
          }
        }
      }
      return !hashListening;
    },
    /*
    	# Method: Finch.reset
    	#   Tears down the current stack and resets the routes
    	#
    	# Arguments:
    	#	none
    */
    reset: function() {
      CurrentTargetPath = NullPath;
      step();
      resetGlobals();
    }
  };

  if (Finch.debug) {
    Finch.private = {
      isObject: isObject,
      isFunction: isFunction,
      isArray: isArray,
      isString: isString,
      isNumber: isNumber,
      trim: trim,
      trimSlashes: trimSlashes,
      startsWith: startsWith,
      endsWith: endsWith,
      contains: contains,
      extend: extend,
      objectsEqual: objectsEqual,
      arraysEqual: arraysEqual,
      NullPath: NullPath,
      NodeType: NodeType,
      RouteSettings: RouteSettings,
      RoutePath: RoutePath,
      RouteNode: RouteNode,
      parseQueryString: parseQueryString,
      getParentRouteString: getParentRouteString,
      getChildRouteString: getChildRouteString,
      splitRouteString: splitRouteString,
      getComponentType: getComponentType,
      getComponentName: getComponentName,
      addRoute: addRoute,
      findPath: findPath,
      findNearestCommonAncestor: findNearestCommonAncestor,
      globals: function() {
        return {
          RootNode: RootNode,
          CurrentPath: CurrentPath,
          CurrentParameters: CurrentParameters
        };
      }
    };
  }

  this.Finch = Finch;

}).call(this);
